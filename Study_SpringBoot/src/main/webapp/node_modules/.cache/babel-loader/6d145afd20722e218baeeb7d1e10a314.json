{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = {};\n  const bases = {};\n  const typeGroups = new Set();\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes = nodes.concat(node.types);\n        typeGroups.add(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics[name]) {\n        let existing = generics[name];\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const type of Object.keys(bases)) {\n    types.push(bases[type]);\n  }\n\n  for (const name of Object.keys(generics)) {\n    types.push(generics[name]);\n  }\n\n  return types;\n}","map":{"version":3,"sources":["C:/Users/zhfld/git/Study_springBoot/Study_SpringBoot/src/main/webapp/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"],"names":["Object","defineProperty","exports","value","default","removeTypeDuplicates","_generated","require","getQualifiedName","node","isIdentifier","name","id","qualification","nodes","generics","bases","typeGroups","Set","types","i","length","indexOf","isAnyTypeAnnotation","isFlowBaseAnnotation","type","isUnionTypeAnnotation","has","concat","add","isGenericTypeAnnotation","existing","typeParameters","params","push","keys"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = removeTypeDuplicates;\r\n\r\nvar _generated = require(\"../../validators/generated\");\r\n\r\nfunction getQualifiedName(node) {\r\n  return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\r\n}\r\n\r\nfunction removeTypeDuplicates(nodes) {\r\n  const generics = {};\r\n  const bases = {};\r\n  const typeGroups = new Set();\r\n  const types = [];\r\n\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n    if (!node) continue;\r\n\r\n    if (types.indexOf(node) >= 0) {\r\n      continue;\r\n    }\r\n\r\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\r\n      return [node];\r\n    }\r\n\r\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\r\n      bases[node.type] = node;\r\n      continue;\r\n    }\r\n\r\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\r\n      if (!typeGroups.has(node.types)) {\r\n        nodes = nodes.concat(node.types);\r\n        typeGroups.add(node.types);\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\r\n      const name = getQualifiedName(node.id);\r\n\r\n      if (generics[name]) {\r\n        let existing = generics[name];\r\n\r\n        if (existing.typeParameters) {\r\n          if (node.typeParameters) {\r\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\r\n          }\r\n        } else {\r\n          existing = node.typeParameters;\r\n        }\r\n      } else {\r\n        generics[name] = node;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    types.push(node);\r\n  }\r\n\r\n  for (const type of Object.keys(bases)) {\r\n    types.push(bases[type]);\r\n  }\r\n\r\n  for (const name of Object.keys(generics)) {\r\n    types.push(generics[name]);\r\n  }\r\n\r\n  return types;\r\n}"]},"metadata":{},"sourceType":"script"}